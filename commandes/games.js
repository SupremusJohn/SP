const { zokou } = require('../framework/zokou');

// Nouvelle commande pour le jeu "Jackpot Whirl"
zokou(
    {
        nomCom: 'whirl',
        reaction: 'üé∞',
        categorie: 'SRPN-TRANSACT'
    },
    async (dest, zk, commandeOptions) => {
        const { repondre, auteurMessage, origineMessage } = commandeOptions;

        // Affichage de l'image et de la l√©gende personnalis√©e pour choisir la mise
        await zk.sendMessage(dest, { 
            image: { url: 'https://telegra.ph/file/4cc2712eee93c105f6739.jpg' }, 
            caption: `‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  ‚ú® *üé∞ Jackpot Whirl üé∞* ‚ú®
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
*üí¨ Tent√© de remport√© le double de votre mise en tirant sur la machine √† sous et aligner les trois symboles.*

> *üéäVoulez-vous tenter votre chance, mise minimum 1.000üß≠ ou 100üíé* \`Oui\` *ou* \`Non\` ?*
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë`
        });

        // fonction pour d√©tecter la confirmation de jeu
        const getConfirmation = async () => {
            const rep = await zk.awaitForMessage({
                sender: auteurMessage,
                chatJid: origineMessage,
                timeout: 30000 // 30 secondes
            });

            let response;
            try {
                response = rep.message.extendedTextMessage.text;
            } catch {
                response = rep.message.conversation;
            }

            if (response.toLowerCase() === 'oui') {
                return true;
            } else if (response.toLowerCase() === 'non') {
                return false;
            } else {
                await repondre('Veuillez r√©pondre par Oui ou Non.');
                return await getConfirmation();
            }
        };

        if (!(await getConfirmation())) {
            delete ongoingGames[auteurMessage];
            return repondre('Jeu annul√©. √Ä la prochaine !');
        }

        // Fonction pour cr√©er un d√©lai (pause)
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Traitement de la r√©ponse
        const generateSlotSymbols = () => {
            const symbols = ['üçí', 'üçã', 'üîî', 'üíé', '‚≠ê','üé≠'];
            return [
                symbols[Math.floor(Math.random() * symbols.length)],
                symbols[Math.floor(Math.random() * symbols.length)],
                symbols[Math.floor(Math.random() * symbols.length)]
            ];
        };

        const [slot1, slot2, slot3] = generateSlotSymbols();
        const message = `üé∞ *Jackpot Whirl* üé∞\n\n*üé≤ R√©sultat :* ${slot1} | ${slot2} | ${slot3}`;

        if (slot1 === slot2 && slot2 === slot3) {
            await repondre(`${message}\n\nüéâ *Jackpot!* Vous avez gagn√© ! üèÜ`);
        } else {
            await repondre(`${message}\n\nüò¢ *Pas de chance cette fois.* R√©essayez !`);
        }
    }
);

// Nouvelle commande pour le jeu "Fortune Spin"
zokou(
    {
        nomCom: 'spin',
        reaction: 'üé°',
        categorie: 'SRPN-GAMES'
    },
    async (dest, zk, commandeOptions) => {
        const spinWheel = () => {
            const colors = ['üî¥', 'üîµ', 'üü¢', 'üü°', 'üü†', 'üü£', '‚ö™', '‚ö´', 'üü§', 'üü°', 'üîµ', 'üü¢'];
            const winningColors = ['üî¥', 'üîµ', 'üü¢', 'üü°', 'üü£', '‚ö™'];
            const chosenColor = colors[Math.floor(Math.random() * colors.length)];
            return { chosenColor, isWinner: winningColors.includes(chosenColor) };
        };

        const { repondre } = commandeOptions;

        const { chosenColor, isWinner } = spinWheel();
        let message = `*üé° Fortune Spin*\nLa roue s'arr√™te sur : ${chosenColor}`;

        if (isWinner) {
            await repondre(`${message}\nüéâ F√©licitations ! Vous avez gagn√© !`);
        } else {
            await repondre(`${message}\nüòû Pas de chance cette fois. Essayez encore !`);
        }
    }
);

// Jeu des Dices
zokou(
    {
        nomCom: 'dice',
        categorie: 'SRPN-GAMES'
    },
    async (dest, zk, commandeOptions) => {
        const { repondre, auteurMessage, ms } = commandeOptions;
        const rollDice = () => Math.floor(Math.random() * 6) + 1;
        
        const dice1 = rollDice();
        const dice2 = rollDice();
        const sum = dice1 + dice2;

        let resultMessage;
        if (sum === 7 || sum === 11) {
            resultMessage = `üé≤ Vous avez lanc√© ${dice1} et ${dice2}. Somme: ${sum}.\nüéâ F√©licitations! Vous avez gagn√©!`;
        } else if (sum === 2, 3, 12) {
            resultMessage = `üé≤ Vous avez lanc√© ${dice1} et ${dice2}. Somme: ${sum}.\nüò¢ D√©sol√©, vous avez perdu.`;
        } else {
            resultMessage = `üé≤ Vous avez lanc√© ${dice1} et ${dice2}. Somme: ${sum}.\nü§î Vous pouvez rejouer!`;
        }

        zk.sendMessage(dest, { text: resultMessage }, { quoted: ms });
    }
);

// Jeu du Multiplicateur
zokou(
    {
        nomCom: 'madness',
        categorie: 'SRPN-GAMES'
    },
    async (dest, zk, commandeOptions) => {
        const { repondre, auteurMessage, ms } = commandeOptions;
        const multiplier = Math.floor(Math.random() * 5) + 1;
        
        let message = `üé∞ Choisissez un chiffre entre 1 et 5.`;
        zk.sendMessage(dest, { text: message }, { quoted: ms });

        const rep = await zk.awaitForMessage({
          sender: auteurMessage,
          chatJid: dest,
          timeout: 30000 // 30 secondes
        });

        let chosenNumber;
        try {
            chosenNumber = parseInt(rep.message.extendedTextMessage.text);
        } catch {
            chosenNumber = parseInt(rep.message.conversation);
        }

        if (isNaN(chosenNumber) || chosenNumber < 1 || chosenNumber > 5) {
            return repondre('Veuillez choisir un chiffre valide entre 1 et 5.');
        }

        let resultMessage;
        if (chosenNumber === multiplier) {
            resultMessage = `üé∞ Le multiplicateur est ${multiplier}. Vous avez choisi ${chosenNumber}.\nüéâ F√©licitations! Vous avez gagn√© ${multiplier} fois votre mise!`;
        } else {
            resultMessage = `üé∞ Le multiplicateur est ${multiplier}. Vous avez choisi ${chosenNumber}.\nüò¢ D√©sol√©, vous avez perdu.`;
        }

        zk.sendMessage(dest, { text: resultMessage }, { quoted: ms });
    }
);

// Nouvelle commande pour le jeu "Mind Mastery"
zokou(
    {
        nomCom: 'mastery',
        reaction: 'üß†',
        categorie: 'SRPN-GAMES'
    },
    async (dest, zk, commandeOptions) => {
        const quizQuestions = [
            {
                question: "Quelle est la capitale de la France ?",
                choices: ["1. Paris", "2. Londres", "3. Berlin"],
                correct: 1
            },
            // Ajoutez plus de questions ici
        ];

        const getRandomQuestion = () => {
            return quizQuestions[Math.floor(Math.random() * quizQuestions.length)];
        };

        const { repondre, auteurMessage } = commandeOptions;

        const question = getRandomQuestion();
        const message = `*üß† Mind Mastery*\n${question.question}\n${question.choices.join('\n')}\nR√©pondez en choisissant le num√©ro de la bonne r√©ponse.`;

        await zk.sendMessage(dest, { text: message });

        // Fonction pour cr√©er un d√©lai (pause)
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Attente de la r√©ponse pendant 30 secondes
        const rep = await zk.awaitForMessage({
            sender: auteurMessage,
            chatJid: dest,
            timeout: 30000 // 30 secondes
        });

        let response;
        try {
            response = rep.message?.extendedTextMessage?.text || rep.message?.conversation;
        } catch (error) {
            response = "";
        }

        // Cr√©ation d'un d√©lai de 30 secondes avant de v√©rifier la r√©ponse
        await delay(30000);

        const chosenAnswer = parseInt(response);
        if (isNaN(chosenAnswer) || chosenAnswer < 1 || chosenAnswer > question.choices.length) {
            await repondre("‚ö†Ô∏è R√©ponse invalide ou pas de r√©ponse. Veuillez r√©pondre avec un num√©ro correspondant √† une des options propos√©es.");
        } else if (chosenAnswer === question.correct) {
            await repondre("üéâ Correct ! Vous avez gagn√© !");
        } else {
            await repondre("üòû Mauvaise r√©ponse. Mieux vaut la prochaine fois.");
        }
    }
);

// Nouvelle commande pour le jeu "Mystic Pairs"
zokou(
    {
        nomCom: 'mysticpairs',
        reaction: 'üÉè',
        categorie: 'SRPN-GAMES'
    },
    async (dest, zk, commandeOptions) => {
        const generateRandomCard = () => {
            const cards = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            return cards[Math.floor(Math.random() * cards.length)];
        };

        const { repondre, auteurMessage } = commandeOptions;

        let card1 = generateRandomCard();
        let card2 = generateRandomCard();

        // Envoyer les cartes au joueur sans r√©v√©ler les valeurs
        let message = `*üÉè Mystic Pairs*\nVous avez re√ßu deux cartes.\n\nVoulez-vous changer une carte avant de poser les cartes sur la table ? R√©pondez par \`1\` pour changer la premi√®re carte, \`2\` pour changer la deuxi√®me, ou \`non\` pour garder les deux.`;
        await zk.sendMessage(dest, { text: message });

        // Fonction pour cr√©er un d√©lai (pause)
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Attente de la r√©ponse du joueur pour changer les cartes
        const rep = await zk.awaitForMessage({
            sender: auteurMessage,
            chatJid: dest,
            timeout: 30000 // 30 secondes
        });

        let response;
        try {
            response = rep.message.extendedTextMessage.text;
        } catch {
            response = rep.message.conversation;
        }

        if (response === '1') {
            card1 = generateRandomCard();
        } else if (response === '2') {
            card2 = generateRandomCard();
        }

        // Demander au joueur de poser les cartes sur la table
        let revealMessage = `Tapez \`table\` pour poser vos cartes sur la table et r√©v√©ler leurs valeurs.`;
        await zk.sendMessage(dest, { text: revealMessage });

        // Attente du mot-cl√© "table" pour r√©v√©ler les cartes
        const revealRep = await zk.awaitForMessage({
            sender: auteurMessage,
            chatJid: dest,
            timeout: 30000 // 30 secondes
        });

        let revealResponse;
        try {
            revealResponse = revealRep.message.extendedTextMessage.text;
        } catch {
            revealResponse = revealRep.message.conversation;
        }

        if (revealResponse.toLowerCase() === 'table') {
            // R√©v√©ler les cartes et d√©terminer le r√©sultat
            let resultMessage = `Vos cartes finales sont : ${card1} et ${card2}.\n`;

            if (card1 === card2) {
                resultMessage += "üéâ Vous avez une paire identique ! Vous avez gagn√© !";
            } else {
                resultMessage += "üòû Pas de paire identique. Mieux vaut la prochaine fois.";
            }

            await repondre(resultMessage);
        } else {
            await repondre("‚è≥ Temps √©coul√© ou commande invalide. Les cartes n'ont pas √©t√© r√©v√©l√©es.");
        }
    }
);